# 0、引言

共收录23种设计模式，这些设计模式被分为三大类：**创建型**、**结构型**和**行为型**，分别包括内容如下：

- 创建型5个

  **单例模式**（Singleton）、**抽象工厂模式**（Abstract Factory）、**建造者模式**（Builder）、**工厂方法模式**（Factory Method）、**原型模式**（Prototype）

- 结构型7个

  **适配器模式**（Adapter）、**桥接模式**（Bridge）、**装饰模式**（Decorator）、**组合模式**（Composite）、**外观模式**（Facade）、**享元模式**（Flyweight）、**代理模式**（Proxy）

- 行为型11个

  **模版方法模式**（Template Method）、**命令模式**（Command）、**迭代器模式**（Iterator）、**观察者模式**（Observer）、**中介者模式**（Mediator）、**备忘录模式**（Memento）、**解释器模式**（Interpreter）、**状态模式**（State）、**策略模式**（Strategy）、**责任链模式**（Chain of Responsibility）、**访问者模式**（Visitor）

# 1、责任链模式

## 1.1、概念

责任链模式是一种行为设计模式， 允许你将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。

该模式允许多个对象来对请求进行处理，而无需让发送者类与具体接收者类相耦合。链可在运行时由遵循标准处理者接口的任意处理者**动态生成**。

一般意义上的责任链模式是说，请求在链上流转时任何一个满足条件的节点处理完请求后就会停止流转并返回，不过还可以根据不同的业务情况做一些改进：

- 请求可以流经处理链的所有节点，不同节点会对请求做不同职责的处理；
- 可以通过上下文参数保存请求对象及上游节点的处理结果，供下游节点依赖，并进一步处理；
- 处理链可支持节点的异步处理，通过实现特定接口判断，是否需要异步处理；
- 责任链对于请求处理节点可以设置**停止标志位**，不是异常，是一种满足业务流转的中断；
- 责任链的拼接方式存在两种，一种是**节点遍历**，一个节点一个节点顺序执行；另一种是**节点嵌套**，内层节点嵌入在外层节点执行逻辑中，类似递归，或者“回”行结构；
- 责任链的节点嵌套拼接方式多被称为**拦截器链**或者**过滤器链**，更易于实现业务流程的切面，比如监控业务执行时长，日志输出，权限校验等；

## 1.2、示例

本示例模拟实现机场登记过程，

第一步办理登机牌，

第二步如果有行李，就办理托运，

第三步核实身份，

第四步安全检查，

第五步完成登机；

其中行李托运是可选的，其他步骤必选，必选步骤有任何不满足就终止登机；旅客对象作为请求参数上下文，**每个步骤会根据旅客对象状态判断是否处理或流转下一个节点**。

## 1.3、登机过程

```go
package chainofresponsibility
 
import "fmt"
 
// BoardingProcessor 登机过程中，各节点统一处理接口
type BoardingProcessor interface {
	SetNextProcessor(processor BoardingProcessor)
	ProcessFor(passenger *Passenger)
}
 
// Passenger 旅客
type Passenger struct {
	name                  string // 姓名
	hasBoardingPass       bool   // 是否办理登机牌
	hasLuggage            bool   // 是否有行李需要托运
	isPassIdentityCheck   bool   // 是否通过身份校验
	isPassSecurityCheck   bool   // 是否通过安检
	isCompleteForBoarding bool   // 是否完成登机
}
 
// baseBoardingProcessor 登机流程处理器基类
type baseBoardingProcessor struct {
	// nextProcessor 下一个登机处理流程
	nextProcessor BoardingProcessor
}
 
// SetNextProcessor 基类中统一实现设置下一个处理器方法
func (b *baseBoardingProcessor) SetNextProcessor(processor BoardingProcessor) {
	b.nextProcessor = processor
}
 
// ProcessFor 基类中统一实现下一个处理器流转
func (b *baseBoardingProcessor) ProcessFor(passenger *Passenger) {
	if b.nextProcessor != nil {
		b.nextProcessor.ProcessFor(passenger)
	}
}
 
// boardingPassProcessor 办理登机牌处理器
type boardingPassProcessor struct {
	baseBoardingProcessor // 引用基类
}
 
func (b *boardingPassProcessor) ProcessFor(passenger *Passenger) {
	if !passenger.hasBoardingPass {
		fmt.Printf("为旅客%s办理登机牌;\n", passenger.name)
		passenger.hasBoardingPass = true
	}
	// 成功办理登机牌后，进入下一个流程处理
	b.baseBoardingProcessor.ProcessFor(passenger)
}
 
// luggageCheckInProcessor 托运行李处理器
type luggageCheckInProcessor struct {
	baseBoardingProcessor
}
 
func (l *luggageCheckInProcessor) ProcessFor(passenger *Passenger) {
	if !passenger.hasBoardingPass {
		fmt.Printf("旅客%s未办理登机牌，不能托运行李;\n", passenger.name)
		return
	}
	if passenger.hasLuggage {
		fmt.Printf("为旅客%s办理行李托运;\n", passenger.name)
	}
	l.baseBoardingProcessor.ProcessFor(passenger)
}
 
// identityCheckProcessor 校验身份处理器
type identityCheckProcessor struct {
	baseBoardingProcessor
}
 
func (i *identityCheckProcessor) ProcessFor(passenger *Passenger) {
	if !passenger.hasBoardingPass {
		fmt.Printf("旅客%s未办理登机牌，不能办理身份校验;\n", passenger.name)
		return
	}
	if !passenger.isPassIdentityCheck {
		fmt.Printf("为旅客%s核实身份信息;\n", passenger.name)
		passenger.isPassIdentityCheck = true
	}
	i.baseBoardingProcessor.ProcessFor(passenger)
}
 
// securityCheckProcessor 安检处理器
type securityCheckProcessor struct {
	baseBoardingProcessor
}
 
func (s *securityCheckProcessor) ProcessFor(passenger *Passenger) {
	if !passenger.hasBoardingPass {
		fmt.Printf("旅客%s未办理登机牌，不能进行安检;\n", passenger.name)
		return
	}
	if !passenger.isPassSecurityCheck {
		fmt.Printf("为旅客%s进行安检;\n", passenger.name)
		passenger.isPassSecurityCheck = true
	}
	s.baseBoardingProcessor.ProcessFor(passenger)
}
 
// completeBoardingProcessor 完成登机处理器
type completeBoardingProcessor struct {
	baseBoardingProcessor
}
 
func (c *completeBoardingProcessor) ProcessFor(passenger *Passenger) {
	if !passenger.hasBoardingPass ||
		!passenger.isPassIdentityCheck ||
		!passenger.isPassSecurityCheck {
		fmt.Printf("旅客%s登机检查过程未完成，不能登机;\n", passenger.name)
		return
	}
	passenger.isCompleteForBoarding = true
	fmt.Printf("旅客%s成功登机;\n", passenger.name)
}
```

## 1.4、测试程序

```go
package chainofresponsibility
 
import "testing"
 
func TestChainOfResponsibility(t *testing.T) {
	boardingProcessor := BuildBoardingProcessorChain()
	passenger := &Passenger{
		name:                  "李四",
		hasBoardingPass:       false,
		hasLuggage:            true,
		isPassIdentityCheck:   false,
		isPassSecurityCheck:   false,
		isCompleteForBoarding: false,
	}
	boardingProcessor.ProcessFor(passenger)
}
 
// BuildBoardingProcessorChain 构建登机流程处理链
func BuildBoardingProcessorChain() BoardingProcessor {
	completeBoardingNode := &completeBoardingProcessor{}
 
	securityCheckNode := &securityCheckProcessor{}
	securityCheckNode.SetNextProcessor(completeBoardingNode)
 
	identityCheckNode := &identityCheckProcessor{}
	identityCheckNode.SetNextProcessor(securityCheckNode)
 
	luggageCheckInNode := &luggageCheckInProcessor{}
	luggageCheckInNode.SetNextProcessor(identityCheckNode)
 
	boardingPassNode := &boardingPassProcessor{}
	boardingPassNode.SetNextProcessor(luggageCheckInNode)
	return boardingPassNode
}
```

## 1.5、运行结果

```
=== RUN   TestChainOfResponsibility
为旅客李四办理登机牌;
为旅客李四办理行李托运;
为旅客李四核实身份信息;
为旅客李四进行安检;
旅客李四成功登机;
--- PASS: TestChainOfResponsibility (0.00s)
PASS
```

# 2、命令模式

## 2.1、概念

命令模式是一种行为设计模式，它可**将请求转换为一个包含与请求相关的所有信息的独立对象**。该转换让你能根据不同的请求将方法参数化、延迟请求执行或将其放入队列中，且能实现可撤销操作。

方法参数化是指**将每个请求参数传入具体命令的工厂方法（go语言没有构造函数）创建命令，同时具体命令会默认设置好接受对象**，这样做的好处是不管请求参数个数及类型，还是接受对象有几个，都会被封装到具体命令对象的成员字段上，并通过统一的Execute接口方法进行调用，屏蔽各个请求的差异，便于命令扩展，多命令组装，回滚等。

## 2.2、示例

控制电饭煲做饭是一个典型的命令模式的场景，电饭煲的控制面板会提供设置煮粥、蒸饭模式，及开始和停止按钮，电饭煲控制系统会根据模式的不同设置相应的火力，压强及时间等参数；煮粥，蒸饭就相当于不同的命令，开始按钮就相当命令触发器，设置好做饭模式，点击开始按钮电饭煲就开始运行，同时还支持停止命令。

## 2.3、电饭煲接收器

```go
package command
 
import "fmt"
 
// ElectricCooker 电饭煲
type ElectricCooker struct {
	fire     string // 火力
	pressure string // 压力
}
 
// SetFire 设置火力
func (e *ElectricCooker) SetFire(fire string) {
	e.fire = fire
}
 
// SetPressure 设置压力
func (e *ElectricCooker) SetPressure(pressure string) {
	e.pressure = pressure
}
 
// Run 持续运行指定时间
func (e *ElectricCooker) Run(duration string) string {
	return fmt.Sprintf("电饭煲设置火力为%s,压力为%s,持续运行%s;", e.fire, e.pressure, duration)
}
 
// Shutdown 停止
func (e *ElectricCooker) Shutdown() string {
	return "电饭煲停止运行。"
}
```

## 2.4、电饭煲命令

```go
package command
 
// CookCommand 做饭指令接口
type CookCommand interface {
	Execute() string // 指令执行方法
}
 
// steamRiceCommand 蒸饭指令
type steamRiceCommand struct {
	electricCooker *ElectricCooker // 电饭煲
}
 
func NewSteamRiceCommand(electricCooker *ElectricCooker) *steamRiceCommand {
	return &steamRiceCommand{
		electricCooker: electricCooker,
	}
}
 
func (s *steamRiceCommand) Execute() string {
	s.electricCooker.SetFire("中")
	s.electricCooker.SetPressure("正常")
	return "蒸饭:" + s.electricCooker.Run("30分钟")
}
 
// cookCongeeCommand 煮粥指令
type cookCongeeCommand struct {
	electricCooker *ElectricCooker
}
 
func NewCookCongeeCommand(electricCooker *ElectricCooker) *cookCongeeCommand {
	return &cookCongeeCommand{
		electricCooker: electricCooker,
	}
}
 
func (c *cookCongeeCommand) Execute() string {
	c.electricCooker.SetFire("大")
	c.electricCooker.SetPressure("强")
	return "煮粥:" + c.electricCooker.Run("45分钟")
}
 
// shutdownCommand 停止指令
type shutdownCommand struct {
	electricCooker *ElectricCooker
}
 
func NewShutdownCommand(electricCooker *ElectricCooker) *shutdownCommand {
	return &shutdownCommand{
		electricCooker: electricCooker,
	}
}
 
func (s *shutdownCommand) Execute() string {
	return s.electricCooker.Shutdown()
}
 
// ElectricCookerInvoker 电饭煲指令触发器
type ElectricCookerInvoker struct {
	cookCommand CookCommand
}
 
// SetCookCommand 设置指令
func (e *ElectricCookerInvoker) SetCookCommand(cookCommand CookCommand) {
	e.cookCommand = cookCommand
}
 
// ExecuteCookCommand 执行指令
func (e *ElectricCookerInvoker) ExecuteCookCommand() string {
	return e.cookCommand.Execute()
}
```

## 2.5、测试程序

```go
package command
 
import (
	"fmt"
	"testing"
)
 
func TestCommand(t *testing.T) {
	// 创建电饭煲，命令接受者
	electricCooker := new(ElectricCooker)
	// 创建电饭煲指令触发器
	electricCookerInvoker := new(ElectricCookerInvoker)
 
	// 蒸饭
	steamRiceCommand := NewSteamRiceCommand(electricCooker)
	electricCookerInvoker.SetCookCommand(steamRiceCommand)
	fmt.Println(electricCookerInvoker.ExecuteCookCommand())
 
	// 煮粥
	cookCongeeCommand := NewCookCongeeCommand(electricCooker)
	electricCookerInvoker.SetCookCommand(cookCongeeCommand)
	fmt.Println(electricCookerInvoker.ExecuteCookCommand())
 
	// 停止
	shutdownCommand := NewShutdownCommand(electricCooker)
	electricCookerInvoker.SetCookCommand(shutdownCommand)
	fmt.Println(electricCookerInvoker.ExecuteCookCommand())
}
```

## 2.6、运行结果

```
=== RUN   TestCommand
蒸饭:电饭煲设置火力为中,压力为正常,持续运行30分钟;
煮粥:电饭煲设置火力为大,压力为强,持续运行45分钟;
电饭煲停止运行。
--- PASS: TestCommand (0.00s)
PASS
```

# 3、迭代器模式

## 3.1、概念

迭代器模式是一种行为设计模式，让你能在不暴露集合底层表现形式 （列表、 栈和树等）的情况下遍历集合中所有的元素。

在迭代器的帮助下， 客户端可以用一个迭代器接口以相似的方式遍历不同集合中的元素。

这里需要注意的是有两个典型的迭代器接口需要分清楚；一个是集合类实现的可以创建迭代器的工厂方法接口一般命名为 Iterable，包含的方法类似 CreateIterator；另一个是迭代器本身的接口，命名为 Iterator，有 Next 及 hasMore 两个主要方法。

## 3.2、示例

一个班级类中包括一个老师和若干个学生，我们要对班级所有成员进行遍历，班级中老师存储在单独的结构字段中，学生存储在另外一个slice字段中，通过迭代器，我们实现统一遍历处理。

## 3.3、班级成员

```go

package iterator
 
import "fmt"
 
// Member 成员接口
type Member interface {
	Desc() string // 输出成员描述信息
}
 
// Teacher 老师
type Teacher struct {
	name    string // 名称
	subject string // 所教课程
}
 
// NewTeacher 根据姓名、课程创建老师对象
func NewTeacher(name, subject string) *Teacher {
	return &Teacher{
		name:    name,
		subject: subject,
	}
}
 
func (t *Teacher) Desc() string {
	return fmt.Sprintf("%s班主任老师负责教%s", t.name, t.subject)
}
 
// Student 学生
type Student struct {
	name     string // 姓名
	sumScore int    // 考试总分数
}
 
// NewStudent 创建学生对象
func NewStudent(name string, sumScore int) *Student {
	return &Student{
		name:     name,
		sumScore: sumScore,
	}
}
 
func (t *Student) Desc() string {
	return fmt.Sprintf("%s同学考试总分为%d", t.name, t.sumScore)
}
```

## 3.4、班级成员迭代器

```go
package iterator
 
// Iterator 迭代器接口
type Iterator interface {
	Next() Member  // 迭代下一个成员
	HasMore() bool // 是否还有
}
 
// memberIterator 班级成员迭代器实现
type memberIterator struct {
	class *Class // 需迭代的班级
	index int    // 迭代索引
}
 
func (m *memberIterator) Next() Member {
	// 迭代索引为-1时，返回老师成员，否则遍历学生slice
	if m.index == -1 {
		m.index++
		return m.class.teacher
	}
	student := m.class.students[m.index]
	m.index++
	return student
}
 
func (m *memberIterator) HasMore() bool {
	return m.index < len(m.class.students)
}
 
// Iterable 可迭代集合接口，实现此接口返回迭代器
type Iterable interface {
	CreateIterator() Iterator
}

// Class 班级，包括老师和同学
type Class struct {
	name     string
	teacher  *Teacher
	students []*Student
}
 
// NewClass 根据班主任老师名称，授课创建班级
func NewClass(name, teacherName, teacherSubject string) *Class {
	return &Class{
		name:    name,
		teacher: NewTeacher(teacherName, teacherSubject),
	}
}
 
// CreateIterator 创建班级迭代器
func (c *Class) CreateIterator() Iterator {
	return &memberIterator{
		class: c,
		index: -1, // 迭代索引初始化为-1，从老师开始迭代
	}
}
 
func (c *Class) Name() string {
	return c.name
}
 
// AddStudent 班级添加同学
func (c *Class) AddStudent(students ...*Student) {
	c.students = append(c.students, students...)
}
```

## 3.5、测试程序

```go
package iterator
 
import (
	"fmt"
	"testing"
)
 
func TestIterator(t *testing.T) {
	class := NewClass("三年级一班", "王明", "数学课")
	class.AddStudent(NewStudent("张三", 389),
		NewStudent("李四", 378),
		NewStudent("王五", 347))
 
	fmt.Printf("%s成员如下:\n", class.Name())
	classIterator := class.CreateIterator()
	for classIterator.HasMore() {
		member := classIterator.Next()
		fmt.Println(member.Desc())
	}
}
```

## 3.6、运行结果

```
=== RUN   TestIterator
三年级一班成员如下:
王明班主任老师负责教数学课
张三同学考试总分为389
李四同学考试总分为378
王五同学考试总分为347
--- PASS: TestIterator (0.00s)
PASS
```

# 4、中介者模式

## 4.1、概念

中介者模式是一种行为设计模式，能让你**减少对象之间混乱无序的依赖关系**。该模式会限制对象之间的直接交互，迫使它们通过一个中介者对象进行合作，将网状依赖变为星状依赖。

中介者能使得程序更易于修改和扩展，而且能更方便地对独立的组件进行复用，因为它们不再依赖于很多其他的类。

中介者模式与观察者模式之间的区别是，**中介者模式解决的是同类或者不同类的多个对象之间多对多的依赖关系**，观察者模式解决的是多个对象与一个对象之间的多对一的依赖关系。

## 4.2、示例

机场塔台调度系统是一个体现中介者模式的典型示例，假设是一个小机场，每次只能同时允许一架飞机起降，每架靠近机场的飞机需要先与塔台沟通是否可以降落，如果没有空闲的跑道，需要在天空盘旋等待，如果有飞机离港，等待的飞机会收到塔台的通知，按先后顺序降落；这种方式，免去多架飞机同时到达机场需要相互沟通降落顺序的复杂性，减少多个飞机间的依赖关系，简化业务逻辑，从而降低系统出问题的风险。

## 4.3、飞机对象

```go
package mediator
 
import "fmt"
 
// Aircraft 飞机接口
type Aircraft interface {
	ApproachAirport() // 抵达机场空域
	DepartAirport()   // 飞离机场
}
 
// airliner 客机
type airliner struct {
	name            string          // 客机型号
	airportMediator AirportMediator // 机场调度
}
 
// NewAirliner 根据指定型号及机场调度创建客机
func NewAirliner(name string, mediator AirportMediator) *airliner {
	return &airliner{
		name:            name,
		airportMediator: mediator,
	}
}
 
func (a *airliner) ApproachAirport() {
	if !a.airportMediator.CanLandAirport(a) { // 请求塔台是否可以降落
		fmt.Printf("机场繁忙，客机%s继续等待降落;\n", a.name)
		return
	}
	fmt.Printf("客机%s成功滑翔降落机场;\n", a.name)
}
 
func (a *airliner) DepartAirport() {
	fmt.Printf("客机%s成功滑翔起飞，离开机场;\n", a.name)
	a.airportMediator.NotifyWaitingAircraft() // 通知等待的其他飞机
}
 
// helicopter 直升机
type helicopter struct {
	name            string
	airportMediator AirportMediator
}
 
// NewHelicopter 根据指定型号及机场调度创建直升机
func NewHelicopter(name string, mediator AirportMediator) *helicopter {
	return &helicopter{
		name:            name,
		airportMediator: mediator,
	}
}
 
func (h *helicopter) ApproachAirport() {
	if !h.airportMediator.CanLandAirport(h) { // 请求塔台是否可以降落
		fmt.Printf("机场繁忙，直升机%s继续等待降落;\n", h.name)
		return
	}
	fmt.Printf("直升机%s成功垂直降落机场;\n", h.name)
}
 
func (h *helicopter) DepartAirport() {
	fmt.Printf("直升机%s成功垂直起飞，离开机场;\n", h.name)
	h.airportMediator.NotifyWaitingAircraft() // 通知其他等待降落的飞机
}
```

## 4.4、机场塔台

```go
package mediator
 
// AirportMediator 机场调度中介者
type AirportMediator interface {
	CanLandAirport(aircraft Aircraft) bool // 确认是否可以降落
	NotifyWaitingAircraft()                // 通知等待降落的其他飞机
}
 
// ApproachTower 机场塔台
type ApproachTower struct {
	hasFreeAirstrip bool
	waitingQueue    []Aircraft // 等待降落的飞机队列
}
 
func (a *ApproachTower) CanLandAirport(aircraft Aircraft) bool {
	if a.hasFreeAirstrip {
		a.hasFreeAirstrip = false
		return true
	}
	// 没有空余的跑道，加入等待队列
	a.waitingQueue = append(a.waitingQueue, aircraft)
	return false
}
 
func (a *ApproachTower) NotifyWaitingAircraft() {
	if !a.hasFreeAirstrip {
		a.hasFreeAirstrip = true
	}
	if len(a.waitingQueue) > 0 {
		// 如果存在等待降落的飞机，通知第一个降落
		first := a.waitingQueue[0]
		a.waitingQueue = a.waitingQueue[1:]
		first.ApproachAirport()
	}
}
```

## 4.5、测试程序

```go
package mediator
 
import "testing"
 
func TestMediator(t *testing.T) {
	// 创建机场调度塔台
	airportMediator := &ApproachTower{hasFreeAirstrip: true}
	// 创建C919客机
	c919Airliner := NewAirliner("C919", airportMediator)
	// 创建米-26重型运输直升机
	m26Helicopter := NewHelicopter("米-26", airportMediator)
 
	c919Airliner.ApproachAirport()  // c919进港降落
	m26Helicopter.ApproachAirport() // 米-26进港等待
 
	c919Airliner.DepartAirport()  // c919飞离，等待的米-26进港降落
	m26Helicopter.DepartAirport() // 最后米-26飞离
}
```

## 4.6、运行结果

```
=== RUN   TestMediator
客机C919成功滑翔降落机场;
机场繁忙，直升机米-26继续等待降落;
客机C919成功滑翔起飞，离开机场;
直升机米-26成功垂直降落机场;
直升机米-26成功垂直起飞，离开机场;
--- PASS: TestMediator (0.00s)
PASS
```

# 5、备忘录模式

## 5.1、概念

备忘录模式是一种行为设计模式， **允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态**。

备忘录不会影响它所处理的对象的内部结构， 也不会影响快照中保存的数据。

一般情况由原发对象保存生成的备忘录对象的状态不能被除原发对象之外的对象访问，所以通过内部类定义具体的备忘录对象是比较安全的，但是go语言不支持内部类定义的方式，因此go语言实现备忘录对象时，首先将备忘录保存的状态设为非导出字段，避免外部对象访问，其次将原发对象的引用保存到备忘录对象中，当通过备忘录对象恢复时，直接操作备忘录的恢复方法，将备份数据状态设置到原发对象中，完成恢复。

## 5.2、示例

大家平时玩的角色扮演闯关游戏的存档机制就可以通过备忘录模式实现，每到一个关键关卡，玩家经常会先保存游戏存档，用于闯关失败后重置，存档会把角色状态及场景状态保存到备忘录中，同时将需要恢复游戏的引用存入备忘录，用于关卡重置。

## 5.3、闯关游戏

```go
package memento
 
import "fmt"
 
// Originator 备忘录模式原发器接口
type Originator interface {
	Save(tag string) Memento // 当前状态保存备忘录
}
 
// RolesPlayGame 支持存档的RPG游戏
type RolesPlayGame struct {
	name          string   // 游戏名称
	rolesState    []string // 游戏角色状态
	scenarioState string   // 游戏场景状态
}
 
// NewRolesPlayGame 根据游戏名称和角色名，创建RPG游戏
func NewRolesPlayGame(name string, roleName string) *RolesPlayGame {
	return &RolesPlayGame{
		name:          name,
		rolesState:    []string{roleName, "血量100"}, // 默认满血
		scenarioState: "开始通过第一关",                   // 默认第一关开始
	}
}
 
// Save 保存RPG游戏角色状态及场景状态到指定标签归档
func (r *RolesPlayGame) Save(tag string) Memento {
	return newRPGArchive(tag, r.rolesState, r.scenarioState, r)
}
 
func (r *RolesPlayGame) SetRolesState(rolesState []string) {
	r.rolesState = rolesState
}
 
func (r *RolesPlayGame) SetScenarioState(scenarioState string) {
	r.scenarioState = scenarioState
}
 
// String 输出RPG游戏简要信息
func (r *RolesPlayGame) String() string {
	return fmt.Sprintf("在%s游戏中，玩家使用%s,%s,%s;", r.name, r.rolesState[0], r.rolesState[1], r.scenarioState)
}
```

## 5.4、游戏存档

```go
package memento
 
import "fmt"
 
// Memento 备忘录接口
type Memento interface {
	Tag() string // 备忘录标签
	Restore()    // 根据备忘录存储数据状态恢复原对象
}
 
// rpgArchive rpg游戏存档，
type rpgArchive struct {
	tag           string         // 存档标签
	rolesState    []string       // 存档的角色状态
	scenarioState string         // 存档游戏场景状态
	rpg           *RolesPlayGame // rpg游戏引用
}
 
// newRPGArchive 根据标签，角色状态，场景状态，rpg游戏引用，创建游戏归档备忘录
func newRPGArchive(tag string, rolesState []string, scenarioState string, rpg *RolesPlayGame) *rpgArchive {
	return &rpgArchive{
		tag:           tag,
		rolesState:    rolesState,
		scenarioState: scenarioState,
		rpg:           rpg,
	}
}
 
func (r *rpgArchive) Tag() string {
	return r.tag
}
 
// Restore 根据归档数据恢复游戏状态
func (r *rpgArchive) Restore() {
	r.rpg.SetRolesState(r.rolesState)
	r.rpg.SetScenarioState(r.scenarioState)
}
 
// RPGArchiveManager RPG游戏归档管理器
type RPGArchiveManager struct {
	archives map[string]Memento // 存储归档标签对应归档
}
 
func NewRPGArchiveManager() *RPGArchiveManager {
	return &RPGArchiveManager{
		archives: make(map[string]Memento),
	}
}
 
// Reload 根据标签重新加载归档数据
func (r *RPGArchiveManager) Reload(tag string) {
	if archive, ok := r.archives[tag]; ok {
		fmt.Printf("重新加载%s;\n", tag)
		archive.Restore()
	}
}
 
// Put 保存归档数据
func (r *RPGArchiveManager) Put(memento Memento) {
	r.archives[memento.Tag()] = memento
}
```

## 5.5、测试程序

```go
package memento
 
import (
	"fmt"
	"testing"
)
 
func TestMemento(t *testing.T) {
	// 创建RPG游戏存档管理器
	rpgManager := NewRPGArchiveManager()
	// 创建RPG游戏
	rpg := NewRolesPlayGame("暗黑破坏神2", "野蛮人战士")
	fmt.Println(rpg)                  // 输出游戏当前状态
	rpgManager.Put(rpg.Save("第一关存档")) // 游戏存档
 
	// 第一关闯关失败
	rpg.SetRolesState([]string{"野蛮人战士", "死亡"})
	rpg.SetScenarioState("第一关闯关失败")
	fmt.Println(rpg)
 
	// 恢复存档，重新闯关
	rpgManager.Reload("第一关存档")
	fmt.Println(rpg)
}
```

## 5.6、运行结果

```
=== RUN   TestMemento
在暗黑破坏神2游戏中，玩家使用野蛮人战士,血量100,开始通过第一关;
在暗黑破坏神2游戏中，玩家使用野蛮人战士,死亡,第一关闯关失败;
重新加载第一关存档;
在暗黑破坏神2游戏中，玩家使用野蛮人战士,血量100,开始通过第一关;
--- PASS: TestMemento (0.00s)
PASS
```

# 6、观察者模式

## 6.1、概念

观察者模式是一种行为设计模式，允许你定义一种订阅机制，可在对象事件发生时通知多个 “观察” 该对象的其他对象。

观察者模式提供了一种作用于任何实现了订阅者接口的对象的机制，可对其事件进行订阅和取消订阅。

观察者模式是最常用的模式之一，是事件总线，分布式消息中间件等各种事件机制的原始理论基础，常用于解耦多对一的对象依赖关系。

**增强的实现功能包括：**

- 当被观察者通过异步实现通知多个观察者时就相当于单进程实例的消息总线；
- 同时还可以根据业务需要，将被观察者所有数据状态变更进行分类为不同的主题，观察者通过不同主题进行订阅；
- 同一个主题又可分为增加，删除，修改事件行为；
- 每个主题可以实现一个线程池，多个主题通过不同的线程池进行处理隔离，线程池可以设置并发线程大小、缓冲区大小及调度策略，比如先进先出，优先级等策略；
- 观察者处理事件时有可能出现异常，所以也可以注册异常处理函数，异常处理也可以通过异常类型进行分类；
- 根据业务需求也可以实现通知异常重试，延迟通知等功能。

## 6.2、示例

信用卡业务消息提醒可通过观察者模式实现，业务消息包括日常消费，出账单，账单逾期，消息提醒包括短信、邮件及电话，根据不同业务的场景会采用不同的消息提醒方式或者多种消息提醒方式，这里**信用卡相当于被观察者**，**观察者相当于不同的通知方式**；日常消费通过短信通知，出账单通过邮件通知，账单逾期三种方式都会进行通知。

## 6.3、通知方式

```go
package observer
 
import "fmt"
 
// Subscriber 订阅者接口
type Subscriber interface {
	Name() string          //订阅者名称
	Update(message string) //订阅更新方法
}
 
// shortMessage 信用卡消息短信订阅者
type shortMessage struct{}
 
func (s *shortMessage) Name() string {
	return "手机短息"
}
 
func (s *shortMessage) Update(message string) {
	fmt.Printf("通过【%s】发送消息:%s\n", s.Name(), message)
}
 
// email 信用卡消息邮箱订阅者
type email struct{}
 
func (e *email) Name() string {
	return "电子邮件"
}
 
func (e *email) Update(message string) {
	fmt.Printf("通过【%s】发送消息:%s\n", e.Name(), message)
}
 
// telephone 信用卡消息电话订阅者
type telephone struct{}
 
func (t *telephone) Name() string {
	return "电话"
}
 
func (t *telephone) Update(message string) {
	fmt.Printf("通过【%s】告知:%s\n", t.Name(), message)
}
```

## 6.4、信用卡业务

```go
package observer
 
import "fmt"
 
// MsgType 信用卡消息类型
type MsgType int
 
const (
	ConsumeType MsgType = iota // 消费消息类型
	BillType                   // 账单消息类型
	ExpireType                 // 逾期消息类型
)
 
// CreditCard 信用卡
type CreditCard struct {
	holder          string                   // 持卡人
	consumeSum      float32                  // 消费总金额
	subscriberGroup map[MsgType][]Subscriber // 根据消息类型分组订阅者
}
 
// NewCreditCard 指定持卡人创建信用卡
func NewCreditCard(holder string) *CreditCard {
	return &CreditCard{
		holder:          holder,
		subscriberGroup: make(map[MsgType][]Subscriber),
	}
}
 
// Subscribe 支持订阅多种消息类型
func (c *CreditCard) Subscribe(subscriber Subscriber, msgTypes ...MsgType) {
	for _, msgType := range msgTypes {
		c.subscriberGroup[msgType] = append(c.subscriberGroup[msgType], subscriber)
	}
}
 
// Unsubscribe 解除订阅多种消息类型
func (c *CreditCard) Unsubscribe(subscriber Subscriber, msgTypes ...MsgType) {
	for _, msgType := range msgTypes {
		if subs, ok := c.subscriberGroup[msgType]; ok {
			c.subscriberGroup[msgType] = removeSubscriber(subs, subscriber)
		}
	}
}
 
func removeSubscriber(subscribers []Subscriber, toRemove Subscriber) []Subscriber {
	length := len(subscribers)
	for i, subscriber := range subscribers {
		if toRemove.Name() == subscriber.Name() {
			subscribers[length-1], subscribers[i] = subscribers[i], subscribers[length-1]
			return subscribers[:length-1]
		}
	}
	return subscribers
}
 
// Consume 信用卡消费
func (c *CreditCard) Consume(money float32) {
	c.consumeSum += money
	c.notify(ConsumeType, fmt.Sprintf("尊敬的持卡人%s,您当前消费%.2f元;", c.holder, money))
}
 
// SendBill 发送信用卡账单
func (c *CreditCard) SendBill() {
	c.notify(BillType, fmt.Sprintf("尊敬的持卡人%s,您本月账单已出，消费总额%.2f元;", c.holder, c.consumeSum))
}
 
// Expire 逾期通知
func (c *CreditCard) Expire() {
	c.notify(ExpireType, fmt.Sprintf("尊敬的持卡人%s,您本月账单已逾期，请及时还款，总额%.2f元;", c.holder, c.consumeSum))
}
 
// notify 根据消息类型通知订阅者
func (c *CreditCard) notify(msgType MsgType, message string) {
	if subs, ok := c.subscriberGroup[msgType]; ok {
		for _, sub := range subs {
			sub.Update(message)
		}
	}
}
```

## 6.5、测试程序

```go
package observer
 
import "testing"
 
func TestObserver(t *testing.T) {
	// 创建张三的信用卡
	creditCard := NewCreditCard("张三")
	// 短信通知订阅信用卡消费及逾期消息
	creditCard.Subscribe(new(shortMessage), ConsumeType, ExpireType)
	// 电子邮件通知订阅信用卡账单及逾期消息
	creditCard.Subscribe(new(email), BillType, ExpireType)
	// 电话通知订阅信用卡逾期消息，同时逾期消息通过三种方式通知
	creditCard.Subscribe(new(telephone), ExpireType)
 
	creditCard.Consume(500.00) // 信用卡消费
	creditCard.Consume(800.00) // 信用卡消费
	creditCard.SendBill()      // 信用卡发送账单
	creditCard.Expire()        // 信用卡逾期
 
	// 信用卡逾期消息取消电子邮件及短信通知订阅
	creditCard.Unsubscribe(new(email), ExpireType)
	creditCard.Unsubscribe(new(shortMessage), ExpireType)
	creditCard.Consume(300.00) // 信用卡消费
	creditCard.Expire()        // 信用卡逾期
}
```

## 6.6、运行结果

```
=== RUN   TestObserver
通过【手机短息】发送消息:尊敬的持卡人张三,您当前消费500.00元;
通过【手机短息】发送消息:尊敬的持卡人张三,您当前消费800.00元;
通过【电子邮件】发送消息:尊敬的持卡人张三,您本月账单已出，消费总额1300.00元;
通过【手机短息】发送消息:尊敬的持卡人张三,您本月账单已逾期，请及时还款，总额1300.00元;
通过【电子邮件】发送消息:尊敬的持卡人张三,您本月账单已逾期，请及时还款，总额1300.00元;
通过【电话】告知:尊敬的持卡人张三,您本月账单已逾期，请及时还款，总额1300.00元;
通过【手机短息】发送消息:尊敬的持卡人张三,您当前消费300.00元;
通过【电话】告知:尊敬的持卡人张三,您本月账单已逾期，请及时还款，总额1600.00元;
--- PASS: TestObserver (0.00s)
PASS
```

# 7、状态模式

状态机

## 7.1、概念

状态模式是一种行为设计模式，让你能在一个对象的内部状态变化时改变其行为，使其看上去就像改变了自身所属的类一样。

该模式将与状态相关的行为抽取到独立的状态类中，让原对象将工作委派给这些类的实例，而不是自行进行处理。

状态迁移有四个元素组成，**起始状态**、**触发迁移的事件**、**终止状态**以及**要执行的动作**，每个具体的状态包含触发状态迁移的执行方法，**迁移方法的实现是执行持有状态对象的动作方法，同时设置状态为下一个流转状态**；持有状态的业务对象包含有触发状态迁移方法，这些迁移方法将请求委托给当前具体状态对象的迁移方法。

## 7.2、示例

Phone手机充电就是一个手机电池状态的流转，一开始手机处于有电状态，插入充电插头后，继续充电到满电状态，并进入断电保护，拔出充电插头后使用手机，由满电逐渐变为没电，最终关机；

状态迁移表：

| 起始状态 | 触发事件   | 终止状态 | 执行动作 |
| :------- | :--------- | :------- | :------- |
| 有电     | 插入充电线 | 满电     | 充电     |
| 有电     | 拔出充电线 | 没电     | 耗电     |
| 满电     | 插入充电线 | 满电     | 停止充电 |
| 满电     | 拔出充电线 | 有电     | 耗电     |
| 没电     | 插入充电线 | 有电     | 充电     |
| 没电     | 拔出充电线 | 没电     | 关机     |

## 7.3、电池状态

```go
package state
 
import "fmt"
 
// BatteryState 电池状态接口，支持手机充电线插拔事件
type BatteryState interface {
	ConnectPlug(iPhone *IPhone) string
	DisconnectPlug(iPhone *IPhone) string
}
 
// fullBatteryState 满电状态
type fullBatteryState struct{}
 
func (s *fullBatteryState) String() string {
	return "满电状态"
}
 
func (s *fullBatteryState) ConnectPlug(iPhone *IPhone) string {
	return iPhone.pauseCharge()
}
 
func (s *fullBatteryState) DisconnectPlug(iPhone *IPhone) string {
	iPhone.SetBatteryState(PartBatteryState)
	return fmt.Sprintf("%s,%s转为%s", iPhone.consume(), s, PartBatteryState)
}
 
// emptyBatteryState 空电状态
type emptyBatteryState struct{}
 
func (s *emptyBatteryState) String() string {
	return "没电状态"
}
 
func (s *emptyBatteryState) ConnectPlug(iPhone *IPhone) string {
	iPhone.SetBatteryState(PartBatteryState)
	return fmt.Sprintf("%s,%s转为%s", iPhone.charge(), s, PartBatteryState)
}
 
func (s *emptyBatteryState) DisconnectPlug(iPhone *IPhone) string {
	return iPhone.shutdown()
}
 
// partBatteryState 部分电状态
type partBatteryState struct{}
 
func (s *partBatteryState) String() string {
	return "有电状态"
}
 
func (s *partBatteryState) ConnectPlug(iPhone *IPhone) string {
	iPhone.SetBatteryState(FullBatteryState)
	return fmt.Sprintf("%s,%s转为%s", iPhone.charge(), s, FullBatteryState)
}
 
func (s *partBatteryState) DisconnectPlug(iPhone *IPhone) string {
	iPhone.SetBatteryState(EmptyBatteryState)
	return fmt.Sprintf("%s,%s转为%s", iPhone.consume(), s, EmptyBatteryState)
}
```

## 7.4、IPhone手机

```go
package state
 
import "fmt"
 
// 电池状态单例，全局统一使用三个状态的单例，不需要重复创建
var (
	FullBatteryState  = new(fullBatteryState)  // 满电
	EmptyBatteryState = new(emptyBatteryState) // 空电
	PartBatteryState  = new(partBatteryState)  // 部分电
)
 
// IPhone 已手机充电为例，实现状态模式
type IPhone struct {
	model        string       // 手机型号
	batteryState BatteryState // 电池状态
}
 
// NewIPhone 创建指定型号手机
func NewIPhone(model string) *IPhone {
	return &IPhone{
		model:        model,
		batteryState: PartBatteryState,
	}
}
 
// BatteryState 输出电池当前状态
func (i *IPhone) BatteryState() string {
	return fmt.Sprintf("iPhone %s 当前为%s", i.model, i.batteryState)
}
 
// ConnectPlug 连接充电线
func (i *IPhone) ConnectPlug() string {
	return fmt.Sprintf("iPhone %s 连接电源线,%s", i.model, i.batteryState.ConnectPlug(i))
}
 
// DisconnectPlug 断开充电线
func (i *IPhone) DisconnectPlug() string {
	return fmt.Sprintf("iPhone %s 断开电源线,%s", i.model, i.batteryState.DisconnectPlug(i))
}
 
// SetBatteryState 设置电池状态
func (i *IPhone) SetBatteryState(state BatteryState) {
	i.batteryState = state
}
 
func (i *IPhone) charge() string {
	return "正在充电"
}
 
func (i *IPhone) pauseCharge() string {
	return "电已满,暂停充电"
}
 
func (i *IPhone) shutdown() string {
	return "手机关闭"
}
 
func (i *IPhone) consume() string {
	return "使用中,消耗电量"
}
```

## 7.5、测试程序

```go
package state
 
import (
	"fmt"
	"testing"
)
 
func TestState(t *testing.T) {
	iPhone13Pro := NewIPhone("13 pro") // 刚创建的手机有部分电
 
	fmt.Println(iPhone13Pro.BatteryState()) // 打印部分电状态
	fmt.Println(iPhone13Pro.ConnectPlug())  // 插上电源插头，继续充满电
	fmt.Println(iPhone13Pro.ConnectPlug())  // 满电后再充电，会触发满电保护
 
	fmt.Println(iPhone13Pro.DisconnectPlug()) // 拔掉电源，使用手机消耗电量，变为有部分电
	fmt.Println(iPhone13Pro.DisconnectPlug()) // 一直使用手机，直到没电
	fmt.Println(iPhone13Pro.DisconnectPlug()) // 没电后会关机
 
	fmt.Println(iPhone13Pro.ConnectPlug()) // 再次插上电源一会，变为有电状态
}
```

## 7.6、运行结果

```
=== RUN   TestState
iPhone 13 pro 当前为有电状态
iPhone 13 pro 连接电源线,正在充电,有电状态转为满电状态
iPhone 13 pro 连接电源线,电已满,暂停充电
iPhone 13 pro 断开电源线,使用中,消耗电量,满电状态转为有电状态
iPhone 13 pro 断开电源线,使用中,消耗电量,有电状态转为没电状态
iPhone 13 pro 断开电源线,手机关闭
iPhone 13 pro 连接电源线,正在充电,没电状态转为有电状态
--- PASS: TestState (0.00s)
PASS
```

# 8、策略模式

## 8.1、概念

策略模式是一种行为设计模式，它能让你定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够相互替换。

原始对象被称为上下文，它包含指向策略对象的引用并将执行行为的任务分派给策略对象。为了改变上下文完成其工作的方式，其他对象可以使用另一个对象来替换当前链接的策略对象。

策略模式是最常用的设计模式，也是比较简单的设计模式，是以多态替换条件表达式重构方法的具体实现，是面向接口编程原则的最直接体现。

## 8.2、示例























